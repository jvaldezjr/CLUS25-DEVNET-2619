---
- name: Organization firmware upgrade
  hosts: localhost
  gather_facts: false

  vars:
    test_org_id: "{{ lookup('env','MERAKI_ORG_ID') }}" # Set this to your test organization ID
    test_product: "wireless"  # Change this to the product you want to test
    test_network_type: "production"  # Change this to the network type you want to test [production, test]
    test_upgrade_time: "2025-07-07T03:00:00"  # Set this to the desired local time upgrade
    freshdesk_api_key: "{{ lookup('env', 'FRESHDESK_API_KEY') }}"
    freshdesk_domain: "{{ lookup('env', 'FRESHDESK_DOMAIN') }}" # Set this to your Freshdesk domain via env variable

  tasks:
    - name: Load version policies from file
      ansible.builtin.include_vars:
        file: version_policies.yml
        name: version_policies

    # - name: Return identity of current API user
    #   cisco.meraki.administered_identities_me_info:
    #   register: current_user

    # - name: Gather Meraki Organizations
    #   cisco.meraki.organizations_info:
    #   register: org_response

    # - name: Store just the list of organizations
    #   ansible.builtin.set_fact:
    #     organizations: "{{ org_response.meraki_response }}"

    - name: Get networks in the organization
      cisco.meraki.networks_info:
        organizationId: "{{ test_org_id }}"
      register: org_networks

    - name: Set networkId fact for testing
      # This is just for testing purposes, to avoid looping through all networks
      ansible.builtin.set_fact:
        test_network_id: "{{ org_networks.meraki_response[1].id }}"

    - name: Get firmware versions for each network
      cisco.meraki.networks_firmware_upgrades_info:
        networkId: "{{ item.id }}"
      loop: "{{ org_networks.meraki_response }}"
      register: org_network_firmware_versions

    - name: Build dictionary of firmware versions by network
      ansible.builtin.set_fact:
        firmware_by_network: >-
          {{ dict(
               org_network_firmware_versions.results
                 | map(attribute='item.id')
                 | zip(
                     org_network_firmware_versions.results
                       | map(attribute='meraki_response')
                   )
             ) }}

    - name: Get network firmware versions
      cisco.meraki.networks_firmware_upgrades_info:
        networkId: "{{ test_network_id }}"
      register: network_firmware_versions

    - name: Debug the network test_network_id current version
      ansible.builtin.debug:
        msg: "{{ firmware_by_network[test_network_id].products[test_product].currentVersion }}"

    - name: Store available upgrades in a list where version is > current and releaseType matches the test policy
      # Use version_compare to select versions > the current version and >= releaseType in version_policies
      ansible.builtin.set_fact:
        available_upgrades: >-
          {{ firmware_by_network[test_network_id].products[test_product].availableVersions
             | selectattr('releaseType', 'in', ['beta', 'candidate', 'stable']
                if version_policies[test_product][test_network_type] == 'beta'
                else (['candidate', 'stable']
                  if version_policies[test_product][test_network_type] == 'candidate'
                else ['stable']
                )
             )
             | selectattr('shortName', 'version_compare', firmware_by_network[test_network_id].products[test_product].currentVersion.shortName, '>')
             | list }}

    - name: Debug the available upgrades for test_network_id
      ansible.builtin.debug:
        msg: "{{ available_upgrades }}"

    - name: Schedule firmware upgrade for test_network_id
      cisco.meraki.networks_firmware_upgrades:
        networkId: "{{ test_network_id }}"
        products: >-
          {{
            dict([
              (test_product, {
                'nextUpgrade': {
                  'time': test_upgrade_time,
                  'toVersion': {
                    'id': available_upgrades[0].id
                  }
                }
              })
            ])
          }}
      when: available_upgrades | length > 0

    - name: Pause the playbook and wait for user confirmation
      ansible.builtin.pause:
        prompt: "Press Enter to continue after confirming the firmware upgrade in the Meraki Dashboard."

    - name: Cancel firmware upgrade for test_network_id
      cisco.meraki.networks_firmware_upgrades:
        networkId: "{{ test_network_id }}"
        products: >-
          {{
            dict([
              (test_product, {
                'nextUpgrade': {
                  'time': test_upgrade_time,
                  'toVersion': {
                    'id': network_firmware_versions.meraki_response.products[test_product].currentVersion.id
                  }
                }
              })
            ])
          }}
      when: available_upgrades | length > 0

    - name: Download Meraki Community RSS feed
      ansible.builtin.get_url:
        url: "https://community.meraki.com/yuzje69629/rss/board?board.id=firmwareupgrades"
        dest: "/tmp/meraki_firmwareupgrades.xml"
        mode: '0644'

    - name: Parse RSS item descriptions
      community.general.xml:
        path: "/tmp/meraki_firmwareupgrades.xml"
        xpath: "//item/description"
        content: text
      register: rss_descriptions

    - name: Parse RSS item links
      community.general.xml:
        path: "/tmp/meraki_firmwareupgrades.xml"
        xpath: "//item/link"
        content: text
      register: rss_links

    - name: Extract description strings from matches
      set_fact:
        rss_description_strings: "{{ rss_descriptions.matches | map(attribute='description') | list }}"

    - name: Extract link strings from matches
      set_fact:
        rss_link_strings: "{{ rss_links.matches | map(attribute='link') | list }}"

    - name: Zip descriptions and links into a dictionary
      set_fact:
        rss_items_dict: "{{ dict(rss_description_strings | zip(rss_link_strings)) }}"

